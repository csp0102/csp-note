# 分布式系统（博客）

原文：https://www.cnblogs.com/xybaby/p/7787034.html

## 一、分布式概要

**1.什么是分布式系统**

* **概念：**分布式系统是由一组网络通过通信、为了完成共同的任务而协调工作的计算机节点组成的系统。
* **目的：**利用更多廉价、普通的机器，完成单个计算机无法完成的**计算、存储**任务。

* **何时使用：**
  * 单个节点的处理能力无法满足计算和存储任务
  * 硬件的提升（如加内存、磁盘、使用更好的CPU）代价高且效率提升不大。
* **缺点：**分布式系统多节点、通过网络通信的拓扑结构，会引入很多单机系统没有的问题，为了解决这些问题，又引入了更多的机制、协议，又带来了更多的问题。

**2.分布式怎么将任务分到计算机节点**

分而治之，即**分片（partition）**

* 计算：对计算任务进行切换，每个节点算一些，最总汇总，这就是MapReduce的思想
* 存储：每个节点存一部分数据

**优点**

* 提升性能和并发，操作被分到不同的分片，相互独立。
* 提升系统的可用性，即使部分分片不能用，其他分片不会收到影响。
* 减轻单个计算机的计算和存储压力。

**3.如何应对系统故障（可用性与可靠性）**

> 在这种一定会出现的“异常”情况下，分布式系统还是需要继续稳定的对外提供服务，即需要较强的容错性。

最简单的办法，就是冗余或者复制集（**Replication**），即**多个节点负责同一个任务**。

最为常见的就是分布式存储中，多个节点复杂存储同一份数据，以此增强可用性与可靠性。同时，Replication也会带来性能的提升，比如数据的locality可以减少用户的等待时间。

 **4.冗余带来的问题（一致性）**

为了可用性与可靠性保证，引用了冗余（复制集）。有了冗余，各个副本间的**一致性**问题就变得很头疼。CAP、FLP这些理论告诉我们，在分布式系统中，没有最佳的选择，都是需要权衡，做出最合适的选择。



## 二、分布式系统的挑战

分布式系统需要大量机器协作，面临诸多的挑战：

**1.异构的机器与网络**

　　　　分布式系统中的机器，配置不一样，其上运行的服务也可能由不同的语言、架构实现，因此处理能力也不一样；节点间通过网络连接，而不同网络运营商提供的网络的带宽、延时、丢包率又不一样。怎么保证大家齐头并进，共同完成目标，这四个不小的挑战。

**2.普遍的节点故障**

　　　　虽然单个节点的故障概率较低，但节点数目达到一定规模，出故障的概率就变高了。分布式系统需要保证故障发生的时候，系统仍然是可用的，这就需要监控节点的状态，在节点故障的情况下将该节点负责的计算、存储任务转移到其他节点

**3.不可靠的网络**

　　　　节点间通过网络通信，而网络是不可靠的。可能的网络问题包括：网络分割、延时、丢包、乱序。

　　　　相比单机过程调用，网络通信最让人头疼的是超时：节点A向节点B发出请求，在约定的时间内没有收到节点B的响应，那么B是否处理了请求，这个是不确定的，这个不确定会带来诸多问题，最简单的，是否要重试请求，节点B会不会多次处理同一个请求。

总而言之，分布式的挑战来自**不确定性**，不确定计算机什么时候crash、断电，不确定磁盘什么时候损坏，不确定每次网络通信要延迟多久，也不确定通信对端是否处理了发送的消息。而分布式的规模放大了这个不确定性，不确定性是令人讨厌的，所以有诸多的分布式理论、协议来保证在这种不确定性的情况下，系统还能继续正常工作。



## 三、分布式系统特性与衡量标准

* **可扩展性**：

  ​		分布式系统的根本目标就是为了处理单个计算机无法处理的任务，当任务增加的时候，分布式系统的处理能力需要随之增加。简单来说，要比较方便的通过增加机器来应对数据量的增长，同时，当任务规模缩减的时候，可以撤掉一些多余的机器，达到动态伸缩的效果

* **可用性与可靠性**：

  ​		一般来说，分布式系统是需要长时间甚至7*24小时提供服务的。可用性是指系统在各种情况对外提供服务的能力，简单来说，可以通过不可用时间与正常服务时间的必知来衡量；而可靠性而是指计算结果正确、存储的数据不丢失。

* **高性能**：

  ​		不管是单机还是分布式系统，大家都非常关注性能。不同的系统对性能的衡量指标是不同的，最常见的：高并发，单位时间内处理的任务越多越好；低延迟：每个任务的平均时间越少越好。这个其实跟操作系统CPU的调度策略很像

* **一致性**：

  ​		分布式系统为了提高可用性可靠性，一般会引入冗余（复制集）。那么如何保证这些节点上的状态一致，这就是分布式系统不得不面对的一致性问题。一致性有很多等级，一致性越强，对用户越友好，但会制约系统的可用性；一致性等级越低，用户就需要兼容数据不一致的情况，但系统的可用性、并发性很高很多。



## 四、组件、理论、协议

> 假设这是一个对外提供服务的大型分布式系统，用户连接到系统，做一些操作，产生一些需要存储的数据，那么在这个过程中，会遇到哪些组件、理论与协议呢

**用一个请求串起来**

​		用户使用Web、APP、SDK，通过HTTP、TCP连接到系统。在分布式系统中，为了高并发、高可用，一般都是多个节点提供相同的服务。那么，第一个问题就是具体选择哪个节点来提供服务，这个就是负载均衡（load balance）。负载均衡的思想很简单，但使用非常广泛，在分布式系统、大型网站的方方面面都有使用，或者说，只要涉及到多个节点提供同质的服务，就需要负载均衡。

　　通过负载均衡找到一个节点，接下来就是真正处理用户的请求，请求有可能简单，也有可能很复杂。简单的请求，比如读取数据，那么很可能是有缓存的，即分布式缓存，如果缓存没有命中，那么需要去数据库拉取数据。对于复杂的请求，可能会调用到系统中其他的服务。

　　承上，假设服务A需要调用服务B的服务，首先两个节点需要通信，网络通信都是建立在TCP/IP协议的基础上，但是，每个应用都手写socket是一件冗杂、低效的事情，因此需要应用层的封装，因此有了HTTP、FTP等各种应用层协议。当系统愈加复杂，提供大量的http接口也是一件困难的事情。因此，有了更进一步的抽象，那就是RPC（remote produce call），是的远程调用就跟本地过程调用一样方便，屏蔽了网络通信等诸多细节，增加新的接口也更加方便。

　　一个请求可能包含诸多操作，即在服务A上做一些操作，然后在服务B上做另一些操作。比如简化版的网络购物，在订单服务上发货，在账户服务上扣款。这两个操作需要保证原子性，要么都成功，要么都不操作。这就涉及到分布式事务的问题，分布式事务是从应用层面保证一致性：某种守恒关系。

　　上面说道一个请求包含多个操作，其实就是涉及到多个服务，分布式系统中有大量的服务，每个服务又是多个节点组成。那么一个服务怎么找到另一个服务（的某个节点呢）？通信是需要地址的，怎么获取这个地址，最简单的办法就是配置文件写死，或者写入到数据库，但这些方法在节点数据巨大、节点动态增删的时候都不大方便，这个时候就需要服务注册与发现：提供服务的节点向一个协调中心注册自己的地址，使用服务的节点去协调中心拉取地址。

　　从上可以看见，协调中心提供了中心化的服务：以一组节点提供类似单点的服务，使用非常广泛，比如命令服务、分布式锁。协调中心最出名的就是chubby，zookeeper。

　　回到用户请求这个点，请求操作会产生一些数据、日志，通常为信息，其他一些系统可能会对这些消息感兴趣，比如个性化推荐、监控等，这里就抽象出了两个概念，消息的生产者与消费者。那么生产者怎么讲消息发送给消费者呢，RPC并不是一个很好的选择，因为RPC肯定得指定消息发给谁，但实际的情况是生产者并不清楚、也不关心谁会消费这个消息，这个时候消息队列就出马了。简单来说，生产者只用往消息队列里面发就行了，队列会将消息按主题（topic）分发给关注这个主题的消费者。消息队列起到了异步处理、应用解耦的作用。

　　上面提到，用户操作会产生一些数据，这些数据忠实记录了用户的操作习惯、喜好，是各行各业最宝贵的财富。比如各种推荐、广告投放、自动识别。这就催生了分布式计算平台，比如Hadoop，Storm等，用来处理这些海量的数据。

　　最后，用户的操作完成之后，用户的数据需要持久化，但数据量很大，大到按个节点无法存储，那么这个时候就需要分布式存储：将数据进行划分放在不同的节点上，同时，为了防止数据的丢失，每一份数据会保存多分。传统的关系型数据库是单点存储，为了在应用层透明的情况下分库分表，会引用额外的代理层。而对于NoSql，一般天然支持分布式。



**一个简化的架构图**

下面用一个不大精确的架构图，尽量还原分布式系统的组成部分（不过只能体现出技术，不好体现出理论）

![img](C:\Users\Administrator\Desktop\在家学习\深度学习图片\分布式简单架构图.png)



**概念与实现**

- 负载均衡：

　　　　Nginx：高性能、高并发的web服务器；功能包括负载均衡、反向代理、静态内容缓存、访问控制；工作在应用层

　　　　LVS： Linux virtual server，基于集群技术和Linux操作系统实现一个高性能、高可用的服务器；工作在网络层

- webserver：

　　　　Java：Tomcat，Apache，Jboss

　　　　Python：gunicorn、uwsgi、twisted、webpy、tornado

- service：　　

　　　　SOA、微服务、spring boot，django

- 容器：

　　　　docker，kubernetes

- cache：

　　　　memcache、redis等

- 协调中心：

　　　　zookeeper、etcd等

　　　　zookeeper使用了Paxos协议Paxos是强一致性，高可用的去中心化分布式。zookeeper的使用场景非常广泛，之后细讲。

- rpc框架：

　　　　grpc、dubbo、brpc

　　　　dubbo是阿里开源的Java语言开发的高性能RPC框架，在阿里系的诸多架构中，都使用了dubbo + spring boot

- 消息队列：

　　　　kafka、rabbitMQ、rocketMQ、QSP

　　　　消息队列的应用场景：异步处理、应用解耦、流量削锋和消息通讯

- 实时数据平台：

　　　　storm、akka

- 离线数据平台：

　　　　hadoop、spark

　　　　PS: apark、akka、kafka都是scala语言写的，看到这个语言还是很牛逼的

- dbproxy：

　　　　cobar也是阿里开源的，在阿里系中使用也非常广泛，是关系型数据库的sharding + replica 代理

- db：

　　　　mysql、oracle、MongoDB、HBase

- 搜索：

　　　　elasticsearch、solr

- 日志：

　　　　rsyslog、elk、flume

------













# 大型网站系统与中间件实践（BOOK）

读书笔记一：https://blog.csdn.net/lonelymanontheway/article/details/82935563

## 第一章 分布式系统介绍

### 1.1 初识分布式系统

#### 1.1.1 分布式系统的定义

分布式系统是由一组网络通过通信、为了完成共同的任务而协调工作的计算机节点组成的系统。

![1583761177861](C:\Users\Administrator\Desktop\在家学习\大型网站系统与中间件实践图片\分布式系统示意图.png)

从用户的角度看，用户面对的就是一个服务器，服务器提供用户所需的服务，而实际上是靠背后的从多服务器组成的一个分布式系统来提高服务。比如访问淘宝网站。

#### 1.1.2 分布式系统的意义

能用一台机器解决问题当然最好，但是（即分布式的意思）

* 升级单机处理能力的性价比越来越低
  * 更换硬件做垂直拓展来提升性能不划算
* 单机处理能力存在瓶颈
  * 单个处理器也有自己的性能瓶颈
* 出于稳定性和可用性的考虑
  * 若采用单机，一旦出现问题，那么系统完全不能用了

单机的能力包括：处理器cpu、内存、磁盘和网络。



### 1.2分布式系统的基础知识

> 先介绍分布式系统中单个节点即单个计算机

#### 1.2.1 组成计算机的5要素

![1583762004726](C:\Users\Administrator\Desktop\在家学习\大型网站系统与中间件实践图片\组成计算机的5要素.png)

上述5个部分组成了整个计算机系统，那么分布式系统相当于一个超级计算机，是否也包含了这5个部分呢？

#### 1.2.2 线程与进程的执行模式

单个进程内的多线程开发难度大，我们需要处理线程间的通信、并发、线程间的协调等问题

* **阿姆达尔定律**

  程序中可并行的代码比例决定你增加处理器（总核心数）所能带来的速度的提升的上限

* **互不通信的多线程模式**

* **基于共享容器协调的多线程模式**

  ![1583762534275](C:\Users\Administrator\Desktop\在家学习\大型网站系统与中间件实践图片\基于共享容器协调的多线程模式.png)

  例如经典的生产者和消费者模型。对于共享的容器或者数据，分为线程安全和线程不安全。

  * 线程安全，直接使用，效率比加锁更高
  * 线程不安全，加锁。若读写比例高，加读写锁比互斥锁更好。

* **通过事件协调的多线程模式**

  ![1583762863107](C:\Users\Administrator\Desktop\在家学习\大型网站系统与中间件实践图片\通过事件协调的多线程模式.png)

  简单的例子：右侧线程一直阻塞等待直到事件通知。实际情况很复制，socket编程中epoll反应堆模型就是基于事件驱动的。

* **多进程模式**

  * 一个进程的多个线程共享了进程的内存空间；多个进程之间的内存空间是独立的。

  * 资源控制更容易，单个进程出问题，不会造成整体的不可用（与单进程多线程的区别）。
  * 多进程间共享数据的代价更大，会涉及序列化和反序列化的开销。
  * 分布式系统，可以近似看作把**单机多进程**变为**多机多进程**

#### 1.2.3网络通信基础知识

* **OSI与TCP/IP网络模型**

  ![1583817215112](C:\Users\Administrator\Desktop\在家学习\大型网站系统与中间件实践图片\OSI与TCPIP网络模型.png)

* **网络IO实现方式**

  * **BIO方式**：阻塞方式实现，一个线程处理一个socket的所有操作，模式简单。如果是server端，需要更多线程来支持并发。

    ![1583817447824](C:\Users\Administrator\Desktop\在家学习\大型网站系统与中间件实践图片\BIO方式.png)

  * **NIO方式**：非阻塞，基于事件驱动思想，采用Reactor模式，好处是可以在一个线程中处理多个socket相关的工作。

    ![1583817582634](C:\Users\Administrator\Desktop\在家学习\大型网站系统与中间件实践图片\NIO方式.png)

    通过Reactor对所有客户端的socket套接字的事件做处理，然后派送到不同的线程中去处理不同请求。

    ![1583818141058](C:\Users\Administrator\Desktop\在家学习\大型网站系统与中间件实践图片\NIO方式1.png)

  * **AIO方式**：异步IO，采用Proactor模式，NIO是先通知再做处理，AIO先做处理再通知。

    ![1583818431679](C:\Users\Administrator\Desktop\在家学习\大型网站系统与中间件实践图片\AIO方式.png)

#### 1.2.4如何把应用从单机拓展到分布式

> 从单机变化到分布式，构成计算机的这5个要素是如何变化的？

* **输入设备的变化**

  分布式系统中的输入设备分为两种：

  * 相互连接的多个节点
  * 人机交互的输入设备

  

* **输出设备的变化**

  与输入设备类似



* **控制器的变化**

  控制器不再是CPU这样的具体电子元件，分布式中控制器主要的作用是协调和控制节点之间的动作和行为。

  * **1.请求发起方和请求处理方中间有一个硬件负载均衡设备**

  ![1583823656393](C:\Users\Administrator\Desktop\在家学习\大型网站系统与中间件实践图片\控制器的变化1.png)

  

  * **2.硬件负载均衡变为软件负载均衡系统（比如LVS）**

    这种方式的特点是代价低，而且控制较强，比较灵活

  ![1583823788294](C:\Users\Administrator\Desktop\在家学习\大型网站系统与中间件实践图片\控制器的变化2.png)

  以上两种方式，称为透明代理。发送请求的一方只需要知道中间透明代理的地址即可。请求处理方也以为是代理在请求服务。

  缺点:

  1. 会增加网络的开销，多一次数据的转发，并增加了一定延时

  2. 若代理出现问题，所有在请求都会受到影响。

     

  * **3.采用名称服务的直连方式的请求调用**

    请求发起方和处理方这两个集群之间没有代理，多了一个“名称服务”的角色，其作用是（地址交换）

    * 收集提供请求处理的服务器的地址信息
    * 提供这些地址信息给请求发起方

    发起请求的机器要根据地址进行**负载均衡**，也就是代理的工作被拆分到名称服务和发起请求的机器上了。

    ![1583824677288](C:\Users\Administrator\Desktop\在家学习\大型网站系统与中间件实践图片\采用名称服务的直连方式的请求调用.png)

    **优势**:可用性增强，也减少了额外的开销，**缺点**：代码的升级较复杂。

    

  * **4.采用规则服务器控制路由的请求直连调用**

    ![1583825296248](C:\Users\Administrator\Desktop\在家学习\大型网站系统与中间件实践图片\采用规则服务器控制路由的请求直连调用.png)

    名称服务通过跟请求处理的机器交互来或者这些机器的地址

    规则服务器本身不和请求处理的机器交互，只负责把规则提供给请求发起的机器

    

  * **5.Master+Worker的方式**

    ![1583825478426](C:\Users\Administrator\Desktop\在家学习\大型网站系统与中间件实践图片\Master+Worker的方式.png)

    由master把任务分配给不同的worker去进行处理，这个方式更多的是任务的分配和管理。

    

* **运算器的变化**

  分布式系统中，运算器由多个节点组成。

  * 场景一

  通过DNS服务器进行调度，DNS服务器返回的是负载均衡的地址。

  ![1583825777559](C:\Users\Administrator\Desktop\在家学习\大型网站系统与中间件实践图片\运算器的变化.png)

  * 场景二

  经典的日志的处理

  把前面master+worker的方式运用到了这个日志处理的场景

  ![1583825907125](C:\Users\Administrator\Desktop\在家学习\大型网站系统与中间件实践图片\运算器的变化1.png)

  

* **存储器的变化**

  需要通过控制器的配合来完成工作

  * 使用代理

    ![1583826443775](C:\Users\Administrator\Desktop\在家学习\大型网站系统与中间件实践图片\存储器的变化1.png)

  * 名称服务

    ![1583826482499](C:\Users\Administrator\Desktop\在家学习\大型网站系统与中间件实践图片\存储器的变化2.png)

  * 规则服务器

    规则服务器中不仅写明了如何对数据做Shareding，还包含了具体的目标KV存储服务器的地址。

    ![1583826506859](C:\Users\Administrator\Desktop\在家学习\大型网站系统与中间件实践图片\存储器的变化3.png)

  * master

    相比于名称服务，Master是根据请求返回对应的KV存储器服务器地址，而不是所有地址，应用服务器上不需要更多的逻辑。

    相比于规则服务器，master自身完成解析和路由选择，并把结果传给应用服务器。

    即master做了全部的解析工作。

    ![1583826733220](C:\Users\Administrator\Desktop\在家学习\大型网站系统与中间件实践图片\存储器变化.png)

    

#### 1.2.5分布式的难点

* **缺乏全局时钟**

  单机控制时序比较容易，分布式中所有节点保持一直的时钟很难做到。

  很多时候我们只用知道动作之间的顺序即可，可以交给单独的集群来区分多个动作的顺序。

* **面对故障的独立性**

  **故障独立性**：分布式系统中，一部分有问题，一部分系统正常。

  实现分布式系统时，要解决故障的独立性

* **处理单点故障**

  **单点故障**：单独负责某个角色和功能的机器发生故障（SPoF）

  在分布式系统中，尽量避免单点故障。

  解决方法：

  * 把某个功能从单机实现变为集群实现（较困难）。
  * 单点备份，能在出问题时自动修复。
  * 降低单点故障分影响范围。

* **事务的挑战**

  两阶段提交（2PC）、最终一致、BASE、CAP、Paxos等，后续讲解。
  
  ​	
  
  ------
  
  
  
  
  
  ​	

## 第二章 大型网站及其架构演进过程

### 2.1 从一个单机的网站说起

![1583845110624](C:\Users\Administrator\Desktop\在家学习\大型网站系统与中间件实践图片\从一个单机的网站说起.png)



### 2.2 单机负载告警，数据库与应用分离

![1583845172644](C:\Users\Administrator\Desktop\在家学习\大型网站系统与中间件实践图片\单机负载告警，数据库与应用分离.png)

将数据库放在了两外一个机器上，采用JDBC连接数据库，只用在其配置文件中将本机地址改为新机器即可。



### 2.3 应用服务器负载告警，让应用服务器走向集群

![1583845352160](C:\Users\Administrator\Desktop\在家学习\大型网站系统与中间件实践图片\应用服务器负载告警，让应用服务器走向集群1.png)

这时会遇到一个与Session有关的**问题**！

**Session**：浏览器与server服务器多次交互，是基于HTTP协议支持会话状态（session state）的机制

![1583845581465](C:\Users\Administrator\Desktop\在家学习\大型网站系统与中间件实践图片\session.png)

![1583845658264](C:\Users\Administrator\Desktop\在家学习\大型网站系统与中间件实践图片\session1.png)

**session问题**：当第一次访问网站时，请求落在了左边的服务器（应用服务器，单机时是一台），那么session就创建在了左边的应用服务器上，如果不做处理，就不能保证接下来的请求每次都落在同一边的服务器上。这就是session问题。

**解决方案**：

* **Session Sticky**

  使用负载均衡器做标识转发

  ![1583845950358](C:\Users\Administrator\Desktop\在家学习\大型网站系统与中间件实践图片\Session Sticky.png)

  问题：

  * 一台web服务器宕机，这台机器上的数据丢失。如果会话中含有登录状态的信息，用户可能需要重新登陆。
  * 负载均衡器要在应用层解析会话标识，开销大。
  * 负载均衡器变为了一个有状态的节点，内存消耗大， 容灾变差。

  打个比方，如果web服务器是我们每次吃饭的饭店，会话数据是碗筷，要保证每次吃饭都用自己的碗筷，就把餐具留在某一家，并且每次吃饭都去这家饭店。

* **Session Replication**

  类似上个比方，我们在每个饭店都留下自己的碗筷，这样就可以自由地选择饭店了。（replication：复制）

  ![1583846378615](C:\Users\Administrator\Desktop\在家学习\大型网站系统与中间件实践图片\Session Replication.png)

  问题：

  * 同步session数据造成了网络带宽开销，每次session变化都要同步，机器数越多，开销越大。
  * 每台服务器都要保存session，若很多人访问网站，则session数据占用严重。

  适合集群机器数少的情况。

* **Session数据集中存储**

  把session数据用数据库集中存储起来。web服务器要使用session时，从数据库读取。

  ![1583846673964](C:\Users\Administrator\Desktop\在家学习\大型网站系统与中间件实践图片\Session数据集中存储.png)

  问题：

  * 读写session会引入网络操作，存在延时和不稳定性。若在内网，问题不大。
  * 集中存储session的机器失效，会影响我们的应用。

* **Cookie Based**

  把session放在cookie中，就好比吃饭把碗筷带在身上，就可以自由选择了。

  ![1583846870000](C:\Users\Administrator\Desktop\在家学习\大型网站系统与中间件实践图片\Cookie Based.png)
  
  问题：
  
  * cookie长度限制。
  * 安全性不够。让服务端数据到了外部网络
  * 带宽消耗和性能影响。
  
* **小结**

  对大型网站而言，前两种时比较好的方案。

  

### 2.4 数据读压力变大，读写分离吧

* **采用数据库作为读库**

  ![1583847316613](C:\Users\Administrator\Desktop\在家学习\大型网站系统与中间件实践图片\采用数据库作为读库.png)

  带来的问题：

  * 数据复制问题

    数据库系统层面对数据复制的支持有限，后面会展开讲解。

  * 应用对于数据源的选择问题

    读写操作选择主库还是备库的问题。

* **搜索引擎其实是一个读库**

  ![1583847673069](C:\Users\Administrator\Desktop\在家学习\大型网站系统与中间件实践图片\搜索引擎其实是一个读库.png)

* **加速数据读写的利器—缓存**

  * **数据缓存**

    大型系统中的数据缓存主要用于分担数据库的读的压力。一遍缓存一些“热”数据。

    应用先访问缓存，如果数据不存在，在访问数据库，并放入缓存。当缓存容量不够，则清除一些不常访问的数据。

    ![1583847768525](C:\Users\Administrator\Desktop\在家学习\大型网站系统与中间件实践图片\数据缓存.png)

  * **页面缓存**

    加速数据的访问最后会反应到页面上，可以直接对一些比较热的动态的页面。

  缓存服务器如redis。



### 2.5 引入分布式存储系统，弥补关系型数据库的不足

除了数据库之外，还有另外存储系统，即分布式存储系统，常见的有：

**分布式文件系统**、**分布式key-value系统**、**分布式数据库**。

引入分布式存储系统之后的结构

![1583848347863](C:\Users\Administrator\Desktop\在家学习\大型网站系统与中间件实践图片\引入分布式存储系统，弥补关系型数据库的不足.png)



### 2.6 读写分离后，数据库又遇瓶颈

通过读写分离和分布式存储系统可以降低主库的压力。但是主库也会遇到瓶颈。

* **专库专用，数据垂直拆分**

  原来一个数据库存储了各种数据，现在将数据分类，存在不同的数据库中。

  ![1583848497792](C:\Users\Administrator\Desktop\在家学习\大型网站系统与中间件实践图片\专库专用，数据垂直拆分.png)

* **数据水平拆分**

  同一业务的数据拆分到不同的数据库中。如何完成，后续分布式数据访问层会讲解。

  ![1583848609964](C:\Users\Administrator\Desktop\在家学习\大型网站系统与中间件实践图片\数据水平拆分.png)

### 2.7 数据库问题解决，新的挑战

* **拆分应用**

  根据功能拆分应用到多个服务器

  ![1583848710555](C:\Users\Administrator\Desktop\在家学习\大型网站系统与中间件实践图片\拆分应用.png)

* **走服务化的路**

  将系统分为三层，简化版

  * 最上层：web系统，用于完成不同的业务功能
  * 中间层：服务中心，不同的服务中心提供不同的服务
  * 最下层：业务的数据库

  与之间的变化：

  * 业务功能引入了远程的服务调用
  * 共享代码都放在各个服务中心
  * 前端web更加注重与浏览器的交互，与数据库的交互交给了服务中心
  * 降低了数据库的连接数
  * 各个部分可以由固定的小队维护

![1583848782572](C:\Users\Administrator\Desktop\在家学习\大型网站系统与中间件实践图片\走服务化的路.png)

要做到服务化结构，需要一些基础组件的支持。



### 2.8 初识消息中间件

消息中间件：面向消息的系统，是分布式系统中完成消息发送和接收的基础软件

好处：异步和解耦

![1583849174323](C:\Users\Administrator\Desktop\在家学习\大型网站系统与中间件实践图片\初识消息中间件.png)



### 2.9 总结

经过演进，我们的网站变成了这个样子。

![1583849264336](C:\Users\Administrator\Desktop\在家学习\大型网站系统与中间件实践图片\总结.png)



------





## 第三章 构建java中间件

### 3.1中间件的定义

中间件不是最上层的应用，也不是最底层的支持系统，是处于“中间“位置的组件。

中间件起到的是桥梁作用，是应用与应用之间的桥梁，也是服务与服务之间的桥梁。

特定的中间件解决特点场景的问题。

本笔记主要介绍三个领域的中间件：

* **远程过程调用和对象访问中间件**

  主要解决分布式环境下应用的相互访问问题。是应用服务化的基础。

* **消息中间件**

  解决应用之间的消息传递、解耦、异步的问题

* **数据访问中间件**

  主要解决应用访问数据库的共性问题

当然，这些只是与大型网站密切相关的中间件。



### 3.2 构建java中间件的基础知识

JVM；垃圾回收与内存堆布局；java并发编程的类、接口和方法；动态代理；反射等java知识。



### 3.3 分布式系统中的java中间件

从第二章知道，大型网站的演进中，包括了应用的拆分、服务的拆分、数据分拆分、应用的解耦

要完成这些工作，**需要对应的中间件产品来解决**。

* 服务框架：应用拆分，完成服务化

  ​	解决集群之间的通信问题。

* 数据层：数据的拆分和整个数据的管理、扩容、迁移等工作

  ​	让应用方便的访问已被分库分表的数据库节点。

* 消息中间件：应用的解耦、提供一种分布式环境下完成事务的思路

![1583909493369](C:\Users\Administrator\Desktop\在家学习\大型网站系统与中间件实践图片\引入中间件的结构图1.png)

-	---	---

​	

​	



## 第四章 服务框架

> **有那些服务框架？**
>
> 业界的互联网巨头公司，都有属于自己的分布式服务框架，如阿里巴巴的Dubbo，HSF，腾讯的Tars，京东的JSF，新浪的Motan，都已经是业界非常成熟的解决方案，其中开源的Dubbo和Motan受到了广大开发者的研究对象。

![1583916550997](C:\Users\Administrator\Desktop\在家学习\大型网站系统与中间件实践图片\服务化方案.png)

![1584004034381](C:\Users\Administrator\Desktop\在家学习\大型网站系统与中间件实践图片\分布式服务框架模块.png)



### 4.2 服务框架的设计与实现

#### 4.2.1 应用从集中式走向分布式所遇到的问题

![1583932083065](.\大型网站系统与中间件实践图片\服务框架要解决的市区.png)

由于服务框架的加入，原来在单机的单个进程中的一个方法调用分散到了两个节点上。远程调用过程如上图所示，说明了从一端到一端的请求过程。



#### 4.2.2 透过实例看服务框架实现

* **客户端的实现**

1. 首先根据要调用的服务名称来获取要提供服务的机器的地址列表，并且从可用地址列表中选择一个要调用的目标机器。（控制器：负载均衡、名称服务、规则服务器等）
2. 构造请求数据包，即把对象变为二进制数据（序列化）
3. 通信，发送请求。
4. 发送结束后，等待远程服务的执行以及结果的返回。
5. 收到结果后，对结果进行反序列化。

![1583932514434](C:\Users\Administrator\Desktop\在家学习\大型网站系统与中间件实践图片\透过实例看服务框架实现.png)

* **服务端的实现**

  ![1583933594236](C:\Users\Administrator\Desktop\在家学习\大型网站系统与中间件实践图片\服务端的实现.png)

  服务端要处理好远程过来的请求以及如何调用这个具体的实现类

  1. 启动后进行监听
  2. 持续接收请求并处理
  3. 对收到的数据反序列化得到数据本身（包括：服务的名字、服务的版本号、需要调用的方法名称和参数、调用的链接）。
  4. 拿到数据后，在本地定位具体提供的服务（getServiceByNameAndVersion）
  5. 进行服务调用，通过**反射**来实现，即得到服务实例具体方法的执行结果后，把需要返回给调用方的结果序列化为二进制数据，通过网络写回给请求发送端。

  

#### 4.2.3 客户端（服务调用端）的具体实现

​					  ![1583934015805](C:\Users\Administrator\Desktop\在家学习\大型网站系统与中间件实践图片\服务端调用的具体工作.png)

* **确定服务框架的使用方式**

  * **运行期服务框架与应用和容器的关系**

    > 什么是web容器？

    ![1583934675778](C:\Users\Administrator\Desktop\在家学习\大型网站系统与中间件实践图片\运行期服务框架与应用和容器的关系1.png)

    ![1583934705039](C:\Users\Administrator\Desktop\在家学习\大型网站系统与中间件实践图片\运行期服务框架与应用和容器的关系2.png)

    

* **服务调用者与服务提供者之间通信方式的选择**

  ![1583934938296](C:\Users\Administrator\Desktop\在家学习\大型网站系统与中间件实践图片\通信问题.png)

  第一种：控制器在服务框架中的一个应用场景

  ![1583935014901](C:\Users\Administrator\Desktop\在家学习\大型网站系统与中间件实践图片\采用透明代理1.png)

  第二种：直连，并引入一个服务注册查找中心，对于调用者，服务注册查找中心，只是提供可用的服务提供者的列表。

  ![1583935043062](C:\Users\Administrator\Desktop\在家学习\大型网站系统与中间件实践图片\直连.png)

  通过以上两种方式，当客户端拿到服务提供者的**地址列表**后，如何选择那个服务器进行调用就是**路由**的问题了。首先考虑就是集群的**负载均衡**，包括随机、轮询、权重等比较常见的实现方式。关于具体的负载均衡的策略，可以参考LVS、nginx等组件。

  

* **引入基于接口、方法、参数的路由**

  在实际场景中，一个服务就是指一个接口的远程实现。除了基础的负载均衡策略外，还有更加颗粒度地控制服务路由的需求。

  ![1584000952462](C:\Users\Administrator\Desktop\在家学习\大型网站系统与中间件实践图片\引入基于接口、方法、参数的路由.png)



* **序列化与反序列化**

  通过路由和流控，我们找到了要调用的目标机器，接下来就是协议适配和序列化的问题。就是把调用远程服务的对象、参数变为服务提供者可以理解、传输的数据。

  

* **网络通信实现选择**（网络编程的知识）

  使用NIO能完成连接复用以及对调用者的同步调用的支持。（同步调用）

  ![1584002061100](C:\Users\Administrator\Desktop\在家学习\大型网站系统与中间件实践图片\网络通信实现选择.png)

  

* **支持多种异步服务调用方式**

  * Oneway：只管发送请求而不关心结果

  ![1584002281860](C:\Users\Administrator\Desktop\在家学习\大型网站系统与中间件实践图片\oneway.png)

  

  * Callback：请求发送后继续执行自己的操作，等对方有响应时进行一个回调，回调的执行不在原请求线程。是一种被动的方式。

    ![1584002413618](C:\Users\Administrator\Desktop\在家学习\大型网站系统与中间件实践图片\Callback.png)
  
  
  
  * Future： Java中非常便利的方式，主动控制超时、获取结果的方式，并且它的执行在原请求线程
  
  ![1584002486791](C:\Users\Administrator\Desktop\在家学习\大型网站系统与中间件实践图片\Future.png)
  
  
  
  * 可靠异步：通过消息中间件保证异步请求能够在远程被执行。
  
    

* **使用Future对远程服务调用优化**

  如果个服务之间存在依赖，那就只能等前一个服务返回后才能进行后续的服务调用。

  这种方法是因为有future的支持，其底层使用的是NIO方式。

  ![1584002792994](C:\Users\Administrator\Desktop\在家学习\大型网站系统与中间件实践图片\多个服务并行调用.png)



#### 4.2.4 服务提供端的设计与实现

服务端的工作有两部分：本地服务的注册管理、根据请求定位服务并执行

* **暴露远程服务**

  服务需要注册到服务注册查找中心，之后才能被服务调用者发现。

  

* **对请求处理的流程**

  ![1584003332370](C:\Users\Administrator\Desktop\在家学习\大型网站系统与中间件实践图片\对请求处理的流程.png)

* **执行不同服务的线程隔离**

  服务提供端的工作线程是一个线程池

  ![1584003468665](C:\Users\Administrator\Desktop\在家学习\大型网站系统与中间件实践图片\执行不同服务的线程隔离.png)

  

* **流控处理**

  隔离不同服务的线程、流控处理都是提高服务端稳定性的方法。

  对不同服务调用者进行分级、确保优先级高的服务调用者被优先提高服务。

  

### 4.6 总结

![1584005798313](C:\Users\Administrator\Desktop\在家学习\大型网站系统与中间件实践图片\引入服务框架之后的变化.png)

服务框架帮助我们完了了应用的架构变化，接下来一章将学习引入中间件后，应用对数据库进行访问方面的变化，即数据访问层。

------







## 第五章 数据访问层

### 5.1 数据库从单机到分布式的挑战和应对

#### 5.1.1 数据库垂直/水平拆分的困难

垂直拆分：把一个数据库中不同业务的数据分到不同的数据库

水平拆分：把一个数据库中同一业务的数据分到不同的数据库

只要是操作数据被拆分到不同库中，就会受到影响，例如存储过程、触发器等



#### 5.1.2 分布式事务

事务的支持对业务来说是非常重要的特性，**一旦拆分数据库，就要面对分布式事务**。

* **什么是分布式事务**

  * **事务**：应用程序中一系列严密的操作，所有操作必须成功完成，否则在每个操作中所作的所有更改都会被撤消。
  
  * **数据库数据特性**
    * 原子性：要么完成，要么不完成
    * 一致性：事务前后，数据库的完整性约束没有被破坏
      * 强一致：任意时刻，所有节点中的数据是一样的。
      * 弱一致：弱一致性包含很多种不同的实现，分布式系统中广泛实现的是最终一致性。
      * 最终一致性：是弱一致性的一种特例，保证用户最终能够读取到某操作对系统特定数据的更新。
    * 隔离性：使用串行化或序列化请求，使事务之间相互隔离
    * 持久性：事务完成后，事务对数据的更改持久地保存在数据库中
  
  * **单机中的事务**：都在一台机器上完成
  
  * **分布式事务**：事务的参与者、支持事务的服务器、资源服务器以及事务管理者位于分布式系统的不同节点。
  
  * **分布式事务模型X/OpenDTP**
  
    * AP：应用程序
    * RM：资源管理器
    * TM：事务管理器
  
    ![1584080483744](C:\Users\Administrator\Desktop\在家学习\大型网站系统与中间件实践图片\分布式事务模型XOpenDTP.png)
  
  * **两阶段提交2PC**
  
    在单机事务中，要么直接提交要么回滚，而在分布式系统中，在提交之前增加一个准备的阶段，所以称为两阶段提交
  
    在准备阶段，任意一个资源出现问题，在第二阶段都进行回滚。
  
    在拆分数据库之后，是否需要两阶段提交协议要看实际情况。
  
    ![1584080970035](C:\Users\Administrator\Desktop\在家学习\大型网站系统与中间件实践图片\两阶段提交2PC.png)
  
    

* **大型网站一致性的基础理论—CAP/BASE**

  分布式事务要做到像单机一样的强一致是很困难的。

  * **CAP理论**

    ![1584082094331](C:\Users\Administrator\Desktop\在家学习\大型网站系统与中间件实践图片\CAP理论.png)

    但是在分布式系统中，并不能同时满足以上三项。增强两项，另外一项受损。

    * 选择CA，放弃分区容忍性，传统单机数据库的选择。
    * 选择AP，放弃一致性，保持最终一致。分布式系统在设计时的选择，例如很多NoSQL就是这样。
    * 选择CP，放弃可用性，可用性比较低。

  * **BASE模型**

    ![1584082582261](C:\Users\Administrator\Desktop\在家学习\大型网站系统与中间件实践图片\BASE模型.png)

    在大型网站中，为了更好的拓展性和可用性，一般不会选择强一致，而采用最终一致的策略。

    

* **Paxos协议**

  > 比两阶段提交更加轻量的、保证一致性的协议

  节点之间的信息交换方式：

  * 共享内存
  * 消息投递：会有很多问题
    * 网络问题、进程挂掉、机器挂掉、进程重启等

  Paxos协议的核心原则：少数服从多数。

在实际开发中，如能避免引入分布式事务最好。



#### 5.1.3 多机的Sequence问题和处理

当转变为水平分库时，原来单机中的Sequence及自增Id的做法需要改变。

**sequence号**：是数据库系统按照一定规则自增的数字序列，作为代理主键，唯一识别。

**问题**：在分库分表后，实现一个自增的不重复的id序列变得困难。

**解决方法**：把所有id集中在一个地方进行管理，对每个id序列独立管理，每台机器使用id时从id生成器上取。

![1584084222042](C:\Users\Administrator\Desktop\在家学习\大型网站系统与中间件实践图片\id生成器.png)



#### 5.1.4 应对多机的数据查询

* **跨库join**

  **join操作**：用于把来自两个或多个表的行结合起来。

  当需要join的数据来自不同的库，就需要跨库join。

  **解决方法有如下几种**

  1. 在应用层把原来数据库的join操作分成多次数据库操作。

     如：根据手机号查询用户id（库A），再根据用户id查询其商品总数（库B）

  2. 数据冗余，对常用信息进行冗余。

  3. 借助外部系统，如**搜索引擎**。//怎么做到的？

     

* **外键约束**

  **主键**：主键是能确定一条记录的唯一标识（某一字段）

  **外键**：是能确定另一张表记录的字段，用于保持数据的一致性。在另一个表中是主键。

  **外键约束**：保持数据一致性，完整性实现**一对一或一对多**关系。

  

* **跨库查询**

  查询在不同库中同意逻辑的表，比如进行了分库分表之后的用户表。

  *未完，比较复杂，涉及排序、函数处理、非排序分页等*





### 5.2 数据访问层的设计与实现

数据访问层就是为了方便应用进行数据读写的抽象层。

#### 5.2.1 外面访问数据层的方式

![1584170344772](C:\Users\Administrator\Desktop\在家学习\大型网站系统与中间件实践图片\外面访问数据层的方式.png)

1. 为用户提供专用API，不推荐，没有通用性。是特定场景下的选择。

2. 通用方式，java应用一般通过JDBC访问数据库。数据层自身作为一个JDBC的实现，暴露JDBC接口给应用。

   使用成本和迁移成本都低。兼容性和拓展性最好。

3. 基于ORM或类ORM接口的方式。在ORM框架（比如iBatis、SpringJDBC）中包装一层，用来实现数据层，对外仍然是原来框架的接口。在兼容方面比较好。



#### 5.2.2 数据层设计流程

![1584170856334](C:\Users\Administrator\Desktop\在家学习\大型网站系统与中间件实践图片\数据层设计流程.png)

* **1.SQL解析**：得到SQL中的关键信息，例如表名、字段、where条件等。

* **2.规则处理**：按规则找到要访问的数据源（数据库），即如何分库分表。尽可能避免跨库查询。

  * **固定哈希算法**

    ![1584171088941](C:\Users\Administrator\Desktop\在家学习\大型网站系统与中间件实践图片\固定哈希算法.png)

  * **一致性哈希算法**

    一致哈希算法最大的变化就是把原来离散的哈希值变为一个范围。

    把整个哈希值范围定义非常大，然后不同节点分管一部分范围。

    ![1584171497089](C:\Users\Administrator\Desktop\在家学习\大型网站系统与中间件实践图片\致性哈希算法.png)

    优点：增加或减少一个节点，只有一个节点会收到影响。

  * **虚拟节点对一致哈希的改进**

    将一个物理节点对应很多个虚拟节点，

    并且同一物理节点的虚拟节点尽量均匀分布

    以此解决增加或着减少节点时，负载不均衡的问题。

  * **映射表与规则自定义**

    映射表根据字段值确定数据源，一般用于对热数据的特殊处理。

    规则自定义，最灵活的计算最终分库的方式。

* **3.改写SQL**

  为什么要改写SQL？

  因为分库分表之后，原来user的表，现在可能变成了use_1、use_1，但是用户只知道user表。

  除了修改表名，还有索引名、平均值计算方式的修改。

* **4.数据源选择**

  在**规则处理**中，我们已经确定了一组数据源，现在要确定具体的数据源。

  ![1584174413931](C:\Users\Administrator\Desktop\在家学习\大型网站系统与中间件实践图片\分库分表之后的结构.png)

  决定了数据分组后，还需要决定访问分组中的哪个库。（redis集群）

  根据当前执行的SQL特点（读、写）、是否在事务中、各个库的权重规则，计算得到这次SQL请求要访问的数据库。

* **5.执行SQL和结果处理**

  执行SQL要注意异常的处理和判断。



#### 5.2.3 独立部署的数据层实现方式

> 具体看一下数据层对应用的具体呈现方式

* **Proxy结构**

  ![1584175145587](C:\Users\Administrator\Desktop\在家学习\大型网站系统与中间件实践图片\PRoxy结构.png)

* **jar包方式**



#### 5.2.4 读写分离的挑战和应对

常见的读写分离场景。存在**数据复制问题**，即把主库数据备份到备库去。

![1584175209943](C:\Users\Administrator\Desktop\在家学习\大型网站系统与中间件实践图片\读写分离的挑战和应对1.png)

* **主库从库非对称**

  * 数据结构相同，多从库对应一主库

    ![1584175417393](C:\Users\Administrator\Desktop\在家学习\大型网站系统与中间件实践图片\通过消息解决数据同步的方案.png)

  * 主备库分库方式不同的数据复制

  * 引入数据变更平台

    ![1584175704750](C:\Users\Administrator\Desktop\在家学习\大型网站系统与中间件实践图片\引入数据变更平台.png)



### 5.3 总结

> 数据量、访问量的增大	—》	对数据库进行分库分表	—》	带来一些共享问题	—》  数据层产生

应用在进行读写时，除了用到了数据库，还会用到分布式文件系统、缓存系统、搜索系统等。应用要非常清楚自己要获取的数据的分布并采用不同的API处理。可以考虑扩大数据层的覆盖，把上述这些不同来源的数据都包装在数据层的访问之下，对外提供统一的接口处理。

最后，整个数据层的结构图：

从应用到DB层就是一个链式处理过程，并且多数组件都是对外提供JDBC的实现，也方便各个组件进行替换。

![1584176188265](C:\Users\Administrator\Desktop\在家学习\大型网站系统与中间件实践图片\数据层的结构图.png)



------





## 第六章 消息中间件

> 有了服务框架和数据层，网站从集中式走向分布式的过程中，很多问题已经得到了解决，而消息中间件可以说是需要的最后一块拼图。
>
> 消息中间件介绍：https://blog.csdn.net/hardworking0323/article/details/81221884
>
> RabbitMQ:https://www.cnblogs.com/hunternet/p/9668851.html

### 6.1 消息中间件的价值

#### 6.1.1 消息中间件的定义

![1584246625193](C:\Users\Administrator\Desktop\在家学习\大型网站系统与中间件实践图片\消息中间件的定义.png)

定义：面向消息的系统，是分布式系统中完成消息发送和接收的基础软件

消息中间件带来了**异步**的特性，对系统进行了**解耦**，这对于大型分布式系统有非常重要的意义。服务框架和数据层有一些功能都依赖于消息中间件。



#### 6.1.2 消息中间件对应用的解耦

* 在没有使用消息中间件时，通过**服务调用**让其他系统感知事件发生（同步调用）

![1584247342739](C:\Users\Administrator\Desktop\在家学习\大型网站系统与中间件实践图片\通过服务调用让其他系统感知事件发生.png)

​		这会让登录系统变得非常复杂，登录系统要被迫依赖非常多的其它系统。

* **引入消息中间件解耦服务调用**

  引入中间件后，上面结构的服务调用，被固定格式的消息代替。

  登录系统负责向消息中间件发送消息，而其他系统则向消息中间件来订阅这个消息，然后完成自己的工作。

  可以看到，通过消息中间件解耦，登录系统不用再关心其他的多个系统，也不用关心如何通知它们。

  ![1584247656926](C:\Users\Administrator\Desktop\在家学习\大型网站系统与中间件实践图片\引入消息中间件解耦服务调用.png)

  > 有一个问题，怎么确保消息中间件收到了来自登录系统的消息呢？



### 6.2 互联网时代的消息中间件

> 互联网特点的消息中间件设计
>
> JMS Java Message Service，是java EE中一个关于消息的规范，而Hornetq、ActiveMQ等产品是对该规范的一个实现。
>
> 知乎，有哪些公司在用，主要用在什么业务场景？：https://www.zhihu.com/question/36048657

#### 6.2.1 如何解决消息发送一致性

**消息发送一致性**：产生消息的动作和发送消息是一致的。就是说业务操作成功了，那么消息一定要发送出去。

有点原子性的意思。

**一般流程**：![1584250596891](C:\Users\Administrator\Desktop\在家学习\大型网站系统与中间件实践图片\消息发送一般流程.png)

**问题**：业务成功，但是消息系统挂掉，会导致消息发送失败，破坏了一致性。

**解决办法**：JMS能够解决，但是存在一些限制并且成本较高。

我们采用下面的方案

![1584251744373](.\大型网站系统与中间件实践图片\解决一致性方案.png)

![1584250849791](.\大型网站系统与中间件实践图片\消息发送一致性解决方案.png)

![1584250993918](.\大型网站系统与中间件实践图片\最终一致行方案正向流程1.png)

![1584251020811](.\大型网站系统与中间件实践图片\最终一致性流程2.png)

为了防止一些异常情况，引入补偿流程

![1584251542394](.\大型网站系统与中间件实践图片\补偿流程.png)

补偿流程的最后一步更新状态如果失败了，就定时重复这个反向流程。

我们可以把实现逻辑封装在一个调用中，再把业务包装成一个对象传进来即可。



#### 6.2.2 如何解决消息中间件与使用者的强依赖关系

> 从上面消息发送一致性可以看到，消息中间件变成了业务的必要依赖。如果消息中间件系统出现了问题，那么将导致业务不可用，如何解决这种强依赖关系呢？

思路如下三种：

1. 提供消息中间件的可靠性。
2. 对于消息中间件系统中影响业务的操作部分，使其可靠性与业务自身一致。
3. 提供弱依赖的支持。

* 第一种方案，是必须要做的事情，但没办法保证百分之百的可靠。

* 第二种方案，其实就是保证如果业务成功，那么就需要**消息先必须入库成功**。

  ![1584252329474](.\大型网站系统与中间件实践图片\如何解决消息中间件与使用者的强依赖关系1.png)

  发送消息变为了虚线，表示不是必要的操作和依赖。要求业务的操作是支持事务的数据库操作。



#### 6.2.3 消息模型对消息接收的影响

> 接下来看一看消息模型，在JMS中有Queue（点对点PTP）和Topic（发布/订阅）两种模型。

* **JMS Queue模型**

  消息生产者应用1和2产生消息，这个消息按到达顺序形成队列。

  消息消费者应用3和4消费消息，一个消息只能被消费一次。（PTP）

  消息从发送端发出来时不能确定最终被谁消费。

  ![1584258509202](.\大型网站系统与中间件实践图片\JMS Queue模型.png)

* **JMS Topic模型**

  消息产生端和JMS内部与上面一致，区别在于消息消费部分

  消息消费者可以消费所有消息，故称为发布订阅模式

  ![1584258889130](C:\Users\Administrator\Desktop\在家学习\大型网站系统与中间件实践图片\JMS Topic模型.png)

* **JMS中客户端连接处理和带来的限制**

  多连接的情况，每个connection都有唯一的clientId

  ![1584259294713](.\大型网站系统与中间件实践图片\多连接的情况1.png)

  ![1584259316462](C:\Users\Administrator\Desktop\在家学习\大型网站系统与中间件实践图片\多连接的情况2.png)

* **我们需要什么样的消息模型**

  我们的需求：

  1. 消息的发送方和生产方都是集群。
  2. 同一个消息的接收方可能有多个集群进行消息的处理。
  3. 不同集群对同一消息的处理不能相互干扰。

  我们需要如下的消息模型：

  场景：8条消息和两个集群，两个集群各有两台电脑，需要这两个集群中的机器分别处理掉所有8条消息，不能重复不能遗漏。

![1584259586842](.\大型网站系统与中间件实践图片\我们需要什么样的消息模型.png)

​		从上可以，Queue和Topic模型直接使用都是有问题的。

​		问题：Queue是一起瓜分，Topic每个机器都会处理八条。

​		解决：集群之间使用Topic，集群内部使用Queue

​		         ![1584259944536](C:\Users\Administrator\Desktop\在家学习\大型网站系统与中间件实践图片\多集群连接方案.png)		



#### 6.2.4 消息订阅者订阅消息的方式

> 下游系统完全通过消息中间件进行自身任务的驱动，“服务框架”中可靠异步调用也需要消息中间件，因此消息中间件提供对于消息的可靠保证是非常重要的。

* **持久订阅**

  订阅关系一旦建立，除非应用显示的取消订阅，否则订阅关系一直存在。即使应用停止运行，还是可以收到消息（M5、M6），消息也会保留，等下次应用开启再投递给应用。

  ![1584262141772](.\大型网站系统与中间件实践图片\持久订阅.png)

* **非持久订阅**

  订阅关系是存续，即应用运行时可以收到消息；应用停止运行，则订阅关系取消，消息也不会保留。

  ![1584262450130](.\大型网站系统与中间件实践图片\非持久订阅.png)



#### 6.2.5 确保消息可靠性的做法

> 从上知，持久订阅才能保证收到所有消息，那么在持久订阅的前提下，整个消息系统如何保证消息的可靠？
>

![1584262850363](.\大型网站系统与中间件实践图片\消息系统示意图.png)

消息从消息发送端到接收端有三个阶段要保证可靠：

1. 消息发送端把消息发送给消息中间件
2. 消息中间件存储消息
3. 消息中间件把消息投递给接收者

下面分别讲解

* **1.消息发送端可靠性的保证**

  需要消息发送端和消息中间件之间的返回结果设定清晰，以及对返回结果的全面处理。

* **2.消息存储的保证**

  存储是存储重要的环节，要做到持久的存储，必须放到外存上，有两种选择：

  1. 自己实现持久存储代码，慎重!

  2. 利用现有的存储系统实现，有很多选择如传统关系型数据库、分布式文件系统和NoSql产品。

  **存储系统实现**：

  * 1.基于文件的消息存储（自己实现），问题较多。

  * 2.采用数据库作为消息存储

  * 3.基于双机内存的消息存储

    使用12两种方式，都会因为磁盘IO而影响系统性能。

    利用双机的内存保证数据可靠，适合消息到了中间件之后大部分消息及时被消费的场景。

    ![1584263898332](C:\Users\Administrator\Desktop\在家学习\大型网站系统与中间件实践图片\基于双机内存的消息存储.png)

* **3.消息投递的可靠性保证**

  * 消息中间件需要显示得收到接收者确认消息处理完毕的信号，才能删除消息。
  * 在投递时一定要采取多线程方式处理。投递消息的线程投递完后直接投递下一个消息；返回的结果先放在内存，最后放入另外的线程池进行处理。



#### 6.2.6 订阅者视角消息重复的产生和应对

* **消息重复产生的原因**

  1. 消息发送端应用的消息重复发送

     ​	消息进入消息存储后，因为各种原因使得消息发送端没有收到“成功”的返回结果，因而导致重复。

  2. 消息中间件向外投递时产生重复

     ​	消息接收者成功处理完消息后，消息中间件不能及时更新投递状态。

  应对办法：使消息接收端的处理是一个幂等操作

  （**幂等**：自己被重复运算的结果等于它自身的元素）

  

#### 6.2.7 消息投递的其他属性支持

* **消息优先级**

  消息优先级的属性，可以让后到达消息中间件消息先被投递。

* **订阅者消息处理顺序和分级订阅**

  ![1584355156868](.\大型网站系统与中间件实践图片\订阅者消息处理顺序和分级订阅.png)

* **自定义属性**

  消息自身的创建时间、类型、投递次数等属性

* **局部顺序**

  ![1584355272585](.\大型网站系统与中间件实践图片\局部顺序.png)

  我们希望消息A和消息B的处理是有序的，且AB之间互不影响，那么在消息中间件内部，就要有非常多的逻辑上独立的队列，支持局部有序。

  ![1584355383407](.\大型网站系统与中间件实践图片\局部有序.png)



#### 6.2.8 保证顺序的消息队列设计

> 随着场景的不同，我们需要一种高效地支持顺序地多集群订阅的消息中间件实现。在前面数据层中，数据变更通知系统，就是这种类型的消息中间件的一个具体场景。

![1584355843235](.\大型网站系统与中间件实践图片\保证顺序的内部消息队列.png)

* 解决本地消息存储的可靠性：
  * 把单个的消息中间件机器变为主备两个节点，slave节点订阅master节点上的所有消息，以进行消息的备份。
  * 和上述一样，但不订阅，采用同步复制的方式备份。master和slave都成功才返回。

* 支持队列的扩容



#### 6.2.9 Push和Pull方法对比

两种消息中间件的实现方式—Push和Pull，他们解决不同场景的问题

![1584356436730](.\大型网站系统与中间件实践图片\Push和Pull方法对比.png)



> 到这里，就结束了对消息中间件的介绍。第456章分别介绍了服务框架、数据层和消息中间件，这三件产品都是解决分布式大型网站的应用架构问题的很重要的产品线。接下来介绍软负载和配置中心，它们同样也不可缺少。





## 第七章 软负载中心与集中配置管理

> 服务框架、数据层和消息中间件的背后，都需要软负载中心和集中配置管理的支持。

### 7.1 初识软负载中心

![](.\大型网站系统与中间件实践图片\初识软负载中心.png)

从图可以，软负载中心有两个**基本的职责**：

1. **聚合地址信息**![1584417690948](C:\Users\Administrator\Desktop\在家学习\大型网站系统与中间件实践图片\集合地址信息.png)

2. **生命周期感知**![1584417728212](C:\Users\Administrator\Desktop\在家学习\大型网站系统与中间件实践图片\生命周期感知.png)



### 7.2 软负载中心的结构

包括：

1. **软负载中心的服务端**
   * 感知服务提供者是否在线
   * 聚合服务提供者的地址信息
   * 传输数据给数据的使用者

2. **软负载中心的客户端**

   作为服务提供者：

   * 把服务提供者提供服务的具体信息主动传给服务端
   * 并随提供服务的变化去更新数据

   作为服务使用者：

   * 向服务端告知自己所需要的数据，并更新数据
   * 进行本地数据缓存，使得每次请求服务获取列表都是一个本地操作

![1584418175825](C:\Users\Administrator\Desktop\在家学习\大型网站系统与中间件实践图片\软负载中心的结构.png)

从上图知，软负载中心内部有**三部分重要数据**：

1. **聚合数据**：就是聚合后的服务提供者的地址列表，Key-Value结构。
2. **订阅关系**：服务使用者把自己需要数据告诉软负载，这就是订阅关系。
3. **连接数据**：连接到软负载中心的节点和已经建立的连接的管理。



### 7.3 内容聚合功能的设计

内容聚合部分需要完成**两个工作**：

1. **保证数据的正确性**
2. **高效聚合数据**

使用key-value结构进行数据管理，要注意：

1. 并发下数据的正确性
2. 数据更新、删除的顺序保证
3. 大量数据同时插入，更新时的性能保证



### 7.4 解决服务上下线的感知

**上下线感知**：软负载负载可用的列表，当服务可用，需要自动把服务加到地址列表；服务不可用，自动从列表中删除。主要有以下两种实现方式。

1. 通过**客户端**与**服务端**的连接感知（软负载的两部分）
   * 方式：通过长连接的心跳检测来判断是否在线
   * 问题：软负载中心压力大时，心跳数据处理不及时，以为心跳超时误判为不在线。
2. 对发布数据中提供的地址端口进行连接的检查
   * 方式：即通过长连接判断服务应用下线时，不直接认定这个服务下线，而是交给另外一个独立的监控应用去验证。



### 7.5 软负载中心的数据分发的特点和设计

#### 7.5.1 数据分发和消息订阅的区别

> 使用软负载服务的数据订阅者为了能够收到所用的服务地址列表，这在软负载中心需要进行数据分发的工作

* **消息中间件的订阅、消息接收    *VS*    软负载中心的订阅、消息接收**

  * 消息中间件*每条消息*都要发送到相关订阅者；而软负载只需保证*最新数据*发送到订阅者。

  * 在消息中间件中，同一集群中的不同机器分享所有信息，一个消息只用同一集群的**一台机器去处理**。

    而在软负载中心，软负载维护的服务数据是所有机器都需要的，需要把这个数据分发给**所有机器**。

    

### 7.6 针对服务化的特性支持

#### 7.6.1 软负载数据分组

在软负载中，通过数据表示（dataId）和分组（group）来唯一确定数据。

分组目的：进行隔离。

分组场景：

* 根据环境进行区分，对不同组的服务提供者和调用者进行隔离（线下）
* 根基优先级区分，多用于线上。

#### 7.6.2 提供自动感知以外的上下线开关

除了自动感知外，还需要指令而非机器状态来控制。这个控制的支持必然要放在软负载。

**通过软负载直接使服务下线**，好处如下：

* 优雅地停止应用，不会因为关闭机器而中断正在执行的服务。
* 用于排错。





### 7.7 从单机到集群

消息中间件及服务框架中的提供者除了可能的数据迁移外，都是依赖软负载来完成服务地址列表更新的。如果软负载走向集群，需要处理以下问题:

1. 数据管理问题
2. 连接管理问题

#### 7.7.1 数据统一管理方案

把数据聚合放在一个地方，这样负责管理连接的机器就是无状态的了，即软负载中心的机器都是对等的，对于数据发布者和订阅者而言，随便选择一台机器即可。

![1584430337561](.\大型网站系统与中间件实践图片\数据统一管理方案.png)

或者将软负载中心的职能分开，如下

![1584430515426](.\大型网站系统与中间件实践图片\将软负载中心的职能.png)

数据统一管理，需要注意“聚合数据”这一数据层的可用性。

#### 7.7.2 数据对等管理方案

把数据分散在各个软负载中心的节点上，并且把自己节点的数据分发到其他节点上，保证每个节点都有整个集群的全部数据，这些节点都是对等的。对于数据发布者和订阅者而言，随便选择一台机器即可。

![1584430912309](C:\Users\Administrator\Desktop\在家学习\大型网站系统与中间件实践图片\数据对等管理方案.png)

 怎么同步数据：

* 软负载互相进行数据的发布，如软负载A作为数据发布者，把数据发布给软负载B



### 7.8 集中配置管理中心

软负载管理服务地址列表、路由规则、消息的订阅关系等，我们可以根据数据是否持久进行分类，

* 软负载中心管理**非持久数据**（非持久订阅关系、服务地址列表）

* 配置管理中心管理**持久数据**（持久订阅关系、路由规则、数据库配置等）

集中配置中心存储的基本都是各个应用集群、中间件产品的关键管理配置信息，以及一些配置开关。

通过集中配置管理中心统一进行运行时的控制，通过改变配置内容影响应用的行为。

![1584431620482](.\大型网站系统与中间件实践图片\集中配置管理中心.png)

> :grey_question::在集中配置管理中心部署Web应用和Nginx？

对集中配置管理中心的使用：

* 提供给应用使用的客户端
* 为控制台或控制脚本提供管理SDK

#### 7.8.1 客户端和服务端的实现以及容灾（略了）

​		



## 第八章 构建大型网站的其他要素

### 8.1 加速静态内容访问速度的CDN

**CDN**： Content Delivery Network，内容分发网络。是一种网络缓存技术。

**作用**：把用户需要的内容分发到离用户近的地方。

**意义**：

* 节省整个广域网的带宽消耗
* 提升用户的访问速度

**什么文件放在CDN**：图片、视频、JS脚本、一些页面框架

![1584582658432](.\大型网站系统与中间件实践图片\浏览器访问网站的流程.png)

![1584582700557](.\大型网站系统与中间件实践图片\引入CDN后浏览器访问网站的流程.png)



### 8.2 大型网站的存储支持

大型网站中对存储的需求不能完全通过关系型数据库来满足

#### 8.2.1 分布式文件系统

对一些**图片、大文本**的存储，使用数据库就不合适了。我们采用分布式文件系统。

有很多开源的系统，如淘宝的TFS，谷歌的GFS。

#### 8.2.2 NoSQL

NoSQL最常见的解释是“non-relational”， “Not Only SQL”也被很多人接受。

NoSQL涵盖的范围更广，基本处于分布式文件系统和SQL关系型数据库之间的系统都被归为NoSQL的范畴。

* 数据模型
  * Key-Value，没有办法进行搞笑的范围查询
  * Ordered Key-Value，Key是有序的，可以进行高效的范围查询
  * BigTable，是结构化数据的分布式存储系统
  * Document，Full-Text Search
  * Graph
* 结构模型

#### 8.2.3 缓存系统

缓存是非持久的存储，是为了加速应用对数据的读取。

Redis和Memcache是两个使用广泛的开源缓存系统。

* **使用缓存的重要场景一**

写数据时候更新存储，然后失效缓存数据；读数据时先读缓存，没有命中再去读存储，并把数据写入缓存。

加上存储到缓存的连线，对于全数据缓存就比较合适，即当存储数据发生变化时，直接从存储去同步数据到缓存中。

![1584596926189](.\大型网站系统与中间件实践图片\常用的缓存使用方式1.png)

* **使用缓存的重要场景二**

  对于web应用的页面渲染内容的缓存。

  ![1584597208740](C:\Users\Administrator\Desktop\在家学习\大型网站系统与中间件实践图片\使用缓存的重要场景二.png)

### 8.3 搜索系统

​	当网站的数据量和访问量逐步增加时，就需要在站内使用搜索技术来解决信息查找的问题。

#### 8.3.1 爬虫问题

对于全网搜索和站内搜索，我们通过爬虫去获取被索引的网站的网页信息。

#### 8.3.2 倒排索引

相对于正排索引，倒排索引就是把原来作为值的内容拆分为索引的key，而原来作为索引的key变为了值。

#### 8.3.3 查询预处理

主要负载对用户输入的搜索内容进行分词和分词后的分析。包括一些同义词的替换和纠正。

#### 8.3.4 相关度计算

在不指定按照某个字段排序的基础上，对搜索结果的排序，排序原则就是被搜索到的内容与要搜素内容之间的相关度。



### 8.4 数据计算支撑

* **离线计算**

  MapReduce模型非常著名和常用。

  ![1584598444041](C:\Users\Administrator\Desktop\在家学习\大型网站系统与中间件实践图片\MapReduce过程.png)

  ![1584598355860](.\大型网站系统与中间件实践图片\MapReduce模型.png)

* **在线计算**

  Strom是一个使用广泛的框架

  ![1584598580425](.\大型网站系统与中间件实践图片\在线计算.png)

  ![1584598683426](.\大型网站系统与中间件实践图片\Strom拓扑.png)

  上述中bolt是整个流中的处理节点。

  在之前提到的消息中间件中，消息中间件作为消息投递的来源，其实也是一个数据处理的源头，订阅消息的应用也是实时地对消息进行处理，相当于一层地的简单流式处理的拓扑，是最简化的一种情况。



------

​																																															***完***



# 有用的链接

分布式实战: https://blog.csdn.net/qq_27384769/article/details/79439782

![1584961540720](.\大型网站系统与中间件实践图片\分布式实战.png)









